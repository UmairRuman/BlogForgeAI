"""
bwa_export.py
─────────────
Export utilities for BlogForge AI.

Functions:
    to_styled_html(md_text, blog_title)  →  str   (full HTML document)
    to_pdf_bytes(md_text, blog_title)    →  bytes  (PDF via ReportLab)
"""

from __future__ import annotations

import re
from io import BytesIO
from typing import List, Tuple


# ══════════════════════════════════════════════════════════════
# 1.  HTML EXPORT
# ══════════════════════════════════════════════════════════════

_HTML_CSS = """
/* ── Reset & base ── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 17px;
    line-height: 1.8;
    color: #1a1a2e;
    background: #fafaf8;
    padding: 0;
}

/* ── Page wrapper ── */
.page {
    max-width: 780px;
    margin: 0 auto;
    padding: 3.5rem 2.5rem 5rem;
    background: #ffffff;
    min-height: 100vh;
    box-shadow: 0 0 60px rgba(0,0,0,.06);
}

/* ── Header banner ── */
.blog-header {
    border-bottom: 3px solid #1e3a5f;
    padding-bottom: 1.8rem;
    margin-bottom: 2.8rem;
}

.blog-meta {
    font-family: 'Courier New', monospace;
    font-size: 12px;
    color: #6b7280;
    letter-spacing: .6px;
    text-transform: uppercase;
    margin-bottom: .8rem;
}

/* ── Typography ── */
h1 {
    font-family: 'Georgia', serif;
    font-size: 2.4rem;
    font-weight: 700;
    color: #0f172a;
    line-height: 1.25;
    margin-bottom: .5rem;
}

h2 {
    font-family: 'Georgia', serif;
    font-size: 1.5rem;
    font-weight: 700;
    color: #1e3a5f;
    margin-top: 2.6rem;
    margin-bottom: .9rem;
    padding-bottom: .35rem;
    border-bottom: 1.5px solid #e2e8f0;
}

h3 {
    font-family: 'Georgia', serif;
    font-size: 1.15rem;
    font-weight: 600;
    color: #334155;
    margin-top: 1.8rem;
    margin-bottom: .5rem;
}

p {
    margin-bottom: 1.25rem;
    color: #334155;
}

/* ── Lists ── */
ul, ol {
    margin: .8rem 0 1.2rem 1.6rem;
    color: #334155;
}

li {
    margin-bottom: .45rem;
    line-height: 1.7;
}

/* ── Code ── */
code {
    font-family: 'Courier New', monospace;
    font-size: .85em;
    background: #f1f5f9;
    color: #0f4c81;
    padding: .1em .38em;
    border-radius: 4px;
    border: 1px solid #e2e8f0;
}

pre {
    background: #0f172a;
    color: #e2e8f0;
    border-radius: 10px;
    padding: 1.4rem 1.6rem;
    overflow-x: auto;
    margin: 1.4rem 0;
    font-size: .88rem;
    line-height: 1.65;
    border-left: 4px solid #2563eb;
}

pre code {
    background: none;
    border: none;
    color: inherit;
    padding: 0;
    font-size: inherit;
}

/* ── Blockquote ── */
blockquote {
    border-left: 4px solid #2563eb;
    margin: 1.4rem 0;
    padding: .8rem 1.2rem;
    background: #eff6ff;
    border-radius: 0 8px 8px 0;
    color: #1e40af;
    font-style: italic;
}

/* ── Table ── */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.4rem 0;
    font-size: .95rem;
}

th {
    background: #1e3a5f;
    color: #ffffff;
    padding: .65rem 1rem;
    text-align: left;
    font-family: 'Courier New', monospace;
    font-size: .82rem;
    letter-spacing: .4px;
}

td {
    padding: .6rem 1rem;
    border-bottom: 1px solid #e2e8f0;
    color: #475569;
}

tr:nth-child(even) td { background: #f8fafc; }

/* ── Images ── */
img {
    max-width: 100%;
    border-radius: 10px;
    margin: 1.4rem 0;
    box-shadow: 0 4px 20px rgba(0,0,0,.1);
}

em { color: #6b7280; font-size: .9rem; display: block; text-align: center; margin-top: -.8rem; margin-bottom: 1rem; }

/* ── Horizontal rule ── */
hr {
    border: none;
    border-top: 2px solid #e2e8f0;
    margin: 2.5rem 0;
}

/* ── Footer ── */
.blog-footer {
    margin-top: 4rem;
    padding-top: 1.2rem;
    border-top: 1px solid #e2e8f0;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    color: #94a3b8;
    text-align: center;
    letter-spacing: .4px;
}

/* ── Print styles ── */
@media print {
    body { background: white; }
    .page { box-shadow: none; padding: 1rem; }
    pre { border: 1px solid #e2e8f0; }
}
"""

_HTML_TEMPLATE = """\
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>{title}</title>
  <style>{css}</style>
</head>
<body>
  <div class="page">
    <header class="blog-header">
      <div class="blog-meta">BlogForge AI &nbsp;·&nbsp; {date_str}</div>
    </header>
    <article>
      {body_html}
    </article>
    <footer class="blog-footer">
      Generated by BlogForge AI &nbsp;·&nbsp; LangGraph + Gemini &nbsp;·&nbsp; {date_str}
    </footer>
  </div>
</body>
</html>
"""


def to_styled_html(md_text: str, blog_title: str = "Blog Post") -> str:
    """
    Convert markdown text → full styled HTML document string.
    Uses the `markdown` standard library package with fenced-code + tables extensions.
    """
    import markdown as _md
    from datetime import date

    extensions = ["fenced_code", "tables", "toc", "nl2br", "attr_list"]
    body_html = _md.markdown(md_text, extensions=extensions)

    return _HTML_TEMPLATE.format(
        title=blog_title,
        css=_HTML_CSS,
        date_str=date.today().strftime("%B %d, %Y"),
        body_html=body_html,
    )


# ══════════════════════════════════════════════════════════════
# 2.  PDF EXPORT  (ReportLab — no external binary needed)
# ══════════════════════════════════════════════════════════════

from reportlab.lib.pagesizes import letter
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.lib.styles import ParagraphStyle
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_JUSTIFY
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, HRFlowable,
    Preformatted, Table, TableStyle, KeepTogether,
    Image as RLImage,
)
from reportlab.lib.styles import getSampleStyleSheet

_W, _H = letter

# ── Colour tokens ───────────────────────────────────────────
_C_DARK   = colors.HexColor("#0f172a")
_C_NAVY   = colors.HexColor("#1e3a5f")
_C_BLUE   = colors.HexColor("#2563eb")
_C_BODY   = colors.HexColor("#334155")
_C_MUTED  = colors.HexColor("#6b7280")
_C_RULE   = colors.HexColor("#e2e8f0")
_C_CODE_BG= colors.HexColor("#0f172a")
_C_CODE_FG= colors.HexColor("#e2e8f0")
_C_BLOCK  = colors.HexColor("#eff6ff")
_C_WHITE  = colors.white


def _make_styles() -> dict:
    return {
        "h1": ParagraphStyle("H1", fontName="Helvetica-Bold", fontSize=22,
                              textColor=_C_DARK, spaceAfter=6, spaceBefore=4, leading=28),
        "h2": ParagraphStyle("H2", fontName="Helvetica-Bold", fontSize=14,
                              textColor=_C_NAVY, spaceAfter=4, spaceBefore=14, leading=18,
                            ),
        "h3": ParagraphStyle("H3", fontName="Helvetica-Bold", fontSize=11.5,
                              textColor=_C_BODY, spaceAfter=3, spaceBefore=8, leading=15),
        "body": ParagraphStyle("Body", fontName="Helvetica", fontSize=10,
                                textColor=_C_BODY, spaceAfter=6, leading=15.5, alignment=TA_JUSTIFY),
        "bullet": ParagraphStyle("Bullet", fontName="Helvetica", fontSize=10,
                                  textColor=_C_BODY, spaceAfter=2, leading=15, leftIndent=14,
                                  firstLineIndent=-8),
        "code_inline": ParagraphStyle("CI", fontName="Courier", fontSize=9,
                                       textColor=_C_BLUE, spaceAfter=6, leading=14),
        "meta": ParagraphStyle("Meta", fontName="Helvetica", fontSize=8.5,
                                textColor=_C_MUTED, spaceAfter=2, alignment=TA_CENTER),
        "footer": ParagraphStyle("Footer", fontName="Helvetica", fontSize=8,
                                  textColor=_C_MUTED, alignment=TA_CENTER),
        "blockquote": ParagraphStyle("BQ", fontName="Helvetica-Oblique", fontSize=10,
                                      textColor=_C_BLUE, spaceAfter=6, leading=15,
                                      leftIndent=16, rightIndent=8),
    }


def _rule():
    return HRFlowable(width="100%", thickness=0.5, color=_C_RULE, spaceAfter=6, spaceBefore=4)


def _section_rule():
    return HRFlowable(width="100%", thickness=1.2, color=_C_NAVY, spaceAfter=6, spaceBefore=2)


def _preformat_block(text: str) -> Table:
    """Render a fenced code block as a dark-background table cell."""
    pre = Preformatted(
        text,
        ParagraphStyle("Pre", fontName="Courier", fontSize=8.5, textColor=_C_CODE_FG,
                       leading=13, leftIndent=0),
    )
    tbl = Table([[pre]], colWidths=[_W - 1.1 * inch])
    tbl.setStyle(TableStyle([
        ("BACKGROUND",    (0, 0), (-1, -1), _C_CODE_BG),
        ("TOPPADDING",    (0, 0), (-1, -1), 10),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 10),
        ("LEFTPADDING",   (0, 0), (-1, -1), 12),
        ("RIGHTPADDING",  (0, 0), (-1, -1), 12),
        ("ROUNDEDCORNERS",(0, 0), (-1, -1), [6, 6, 6, 6]),
    ]))
    return tbl


def _blockquote_block(text: str, st: dict) -> Table:
    para = Paragraph(text, st["blockquote"])
    tbl = Table([[para]], colWidths=[_W - 1.1 * inch])
    tbl.setStyle(TableStyle([
        ("BACKGROUND",    (0, 0), (-1, -1), _C_BLOCK),
        ("TOPPADDING",    (0, 0), (-1, -1), 8),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 8),
        ("LEFTPADDING",   (0, 0), (-1, -1), 14),
        ("RIGHTPADDING",  (0, 0), (-1, -1), 10),
        ("LINEBEFORE",    (0, 0), (0, -1),  3, _C_BLUE),
    ]))
    return tbl


# ── Image embedding helper ───────────────────────────────────
_IMG_MD_RE  = re.compile(r"^!\[(?P<alt>[^\]]*)\]\((?P<src>[^)]+)\)$")
_MAX_IMG_W  = _W - 1.7 * inch   # honour page margins

def _embed_image(src: str, alt: str, caption: str, st: dict) -> list:
    """
    Resolve `src` relative to cwd, scale to fit page width,
    and return a list of Flowables: [Spacer, image-table, optional-caption, Spacer].
    Returns an empty list if the file cannot be found/loaded.
    """
    from pathlib import Path

    # strip leading ./ so Path resolves relative to cwd
    clean = src.strip().lstrip("./")
    img_path = Path(clean)

    if not img_path.exists():
        # try resolving from absolute cwd
        img_path = Path.cwd() / clean

    if not img_path.exists():
        # graceful fallback: show a note instead of crashing
        note = Paragraph(
            f'<i>[Image not found: {src}]</i>',
            ParagraphStyle("ImgMiss", fontName="Helvetica-Oblique", fontSize=9,
                           textColor=_C_MUTED, spaceAfter=4),
        )
        return [note]

    try:
        # load and measure natural size
        img = RLImage(str(img_path))
        nat_w, nat_h = img.imageWidth, img.imageHeight

        # scale down to fit max width, preserve aspect ratio
        if nat_w > _MAX_IMG_W:
            scale   = _MAX_IMG_W / nat_w
            disp_w  = _MAX_IMG_W
            disp_h  = nat_h * scale
        else:
            disp_w, disp_h = float(nat_w), float(nat_h)

        img.drawWidth  = disp_w
        img.drawHeight = disp_h

        # centre the image in a single-cell table
        tbl = Table([[img]], colWidths=[_W - 1.1 * inch])
        tbl.setStyle(TableStyle([
            ("ALIGN",         (0, 0), (-1, -1), "CENTER"),
            ("TOPPADDING",    (0, 0), (-1, -1), 4),
            ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
        ]))

        flowables: list = [Spacer(1, 8), tbl]

        # caption (italic, centred, muted)
        cap_text = caption or alt
        if cap_text:
            flowables.append(
                Paragraph(
                    f"<i>{cap_text}</i>",
                    ParagraphStyle("ImgCap", fontName="Helvetica-Oblique", fontSize=9,
                                   textColor=_C_MUTED, alignment=TA_CENTER,
                                   spaceAfter=2, spaceBefore=2),
                )
            )

        flowables.append(Spacer(1, 8))
        return flowables

    except Exception:
        return []   # silently skip unreadable images


# ── Markdown line-level inline cleaner ──────────────────────
_INLINE_CODE_RE = re.compile(r"`([^`]+)`")
_BOLD_RE        = re.compile(r"\*\*(.+?)\*\*")
_ITALIC_RE      = re.compile(r"\*(.+?)\*")
_LINK_RE        = re.compile(r"\[([^\]]+)\]\([^)]+\)")
_IMG_RE         = re.compile(r"!\[[^\]]*\]\([^)]+\)")


def _inline(text: str) -> str:
    """Convert inline markdown to ReportLab XML-safe markup."""
    text = _IMG_RE.sub("", text)                                          # strip images
    text = _LINK_RE.sub(r"\1", text)                                      # keep link text
    text = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    text = _INLINE_CODE_RE.sub(r'<font name="Courier" color="#2563eb">\1</font>', text)
    text = _BOLD_RE.sub(r"<b>\1</b>", text)
    text = _ITALIC_RE.sub(r"<i>\1</i>", text)
    return text


# ── Block-level parser ───────────────────────────────────────
def _parse_md_to_flowables(md_text: str, st: dict) -> list:
    """
    Walk markdown line-by-line and produce ReportLab Flowable objects.
    Handles: H1-H3, paragraphs, fenced code, blockquotes, bullets, numbered lists, HR.
    """
    flowables = []
    lines = md_text.splitlines()
    i = 0
    para_buf: List[str] = []

    def flush_para():
        if para_buf:
            text = " ".join(para_buf).strip()
            if text:
                flowables.append(Paragraph(_inline(text), st["body"]))
            para_buf.clear()

    while i < len(lines):
        raw = lines[i]
        stripped = raw.strip()

        # ── fenced code block
        if stripped.startswith("```"):
            flush_para()
            lang = stripped[3:].strip()
            code_lines = []
            i += 1
            while i < len(lines) and not lines[i].strip().startswith("```"):
                code_lines.append(lines[i])
                i += 1
            code_text = "\n".join(code_lines)
            flowables.append(Spacer(1, 4))
            flowables.append(_preformat_block(code_text))
            flowables.append(Spacer(1, 6))
            i += 1
            continue

        # ── blockquote
        if stripped.startswith("> "):
            flush_para()
            bq_text = stripped[2:].strip()
            flowables.append(_blockquote_block(_inline(bq_text), st))
            i += 1
            continue

        # ── horizontal rule
        if stripped in ("---", "***", "___") or re.match(r"^-{3,}$", stripped):
            flush_para()
            flowables.append(_rule())
            i += 1
            continue

        # ── H1
        if stripped.startswith("# "):
            flush_para()
            text = stripped[2:].strip()
            flowables.append(Spacer(1, 4))
            flowables.append(Paragraph(_inline(text), st["h1"]))
            flowables.append(_section_rule())
            i += 1
            continue

        # ── H2
        if stripped.startswith("## "):
            flush_para()
            text = stripped[3:].strip()
            flowables.append(Spacer(1, 6))
            flowables.append(Paragraph(_inline(text), st["h2"]))
            flowables.append(HRFlowable(width="100%", thickness=0.8, color=_C_RULE,
                                         spaceAfter=4, spaceBefore=0))
            i += 1
            continue

        # ── H3
        if stripped.startswith("### "):
            flush_para()
            text = stripped[4:].strip()
            flowables.append(Paragraph(_inline(text), st["h3"]))
            i += 1
            continue

        # ── unordered bullet
        if re.match(r"^[-*+] ", stripped):
            flush_para()
            text = stripped[2:].strip()
            flowables.append(Paragraph(f"• &nbsp; {_inline(text)}", st["bullet"]))
            i += 1
            continue

        # ── numbered list
        if re.match(r"^\d+\. ", stripped):
            flush_para()
            text = re.sub(r"^\d+\. ", "", stripped).strip()
            flowables.append(Paragraph(f"  {_inline(text)}", st["bullet"]))
            i += 1
            continue

        # ── blank line → paragraph break
        if stripped == "":
            flush_para()
            i += 1
            continue

        # ── image line → embed in PDF with optional caption
        if stripped.startswith("!["):
            flush_para()
            m = _IMG_MD_RE.match(stripped)
            if m:
                alt_text = m.group("alt").strip()
                src_text = m.group("src").strip()

                # peek at the NEXT line — if it's *italic caption*, consume it
                caption_text = ""
                if i + 1 < len(lines):
                    next_stripped = lines[i + 1].strip()
                    cap_m = re.match(r"^\*(?P<cap>.+)\*$", next_stripped)
                    if cap_m:
                        caption_text = cap_m.group("cap").strip()
                        i += 1  # consume caption line

                flowables.extend(_embed_image(src_text, alt_text, caption_text, st))
            i += 1
            continue

        # ── regular text → accumulate into paragraph
        para_buf.append(stripped)
        i += 1

    flush_para()
    return flowables


def to_pdf_bytes(md_text: str, blog_title: str = "Blog Post") -> bytes:
    """
    Convert markdown text → PDF bytes via ReportLab.
    No external binaries required.
    """
    from datetime import date

    buf = BytesIO()
    doc = SimpleDocTemplate(
        buf,
        pagesize=letter,
        leftMargin=0.85 * inch,
        rightMargin=0.85 * inch,
        topMargin=0.75 * inch,
        bottomMargin=0.75 * inch,
        title=blog_title,
        author="BlogForge AI",
    )

    st = _make_styles()
    story = []

    # ── top meta bar
    date_str = date.today().strftime("%B %d, %Y")
    story.append(Paragraph(f"BlogForge AI  ·  {date_str}", st["meta"]))
    story.append(HRFlowable(width="100%", thickness=2, color=_C_NAVY, spaceAfter=14, spaceBefore=4))

    # ── body
    story.extend(_parse_md_to_flowables(md_text, st))

    # ── footer rule + text
    story.append(Spacer(1, 20))
    story.append(_rule())
    story.append(Paragraph(
        f"Generated by BlogForge AI  ·  LangGraph + Gemini  ·  {date_str}",
        st["footer"]
    ))

    doc.build(story)
    return buf.getvalue()